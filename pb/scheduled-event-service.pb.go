// Code generated by protoc-gen-go. DO NOT EDIT.
// source: scheduled-event-service.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Schedules struct {
	Events               *ScheduledEvents     `protobuf:"bytes,1,opt,name=events,proto3" json:"events,omitempty"`
	When                 *timestamp.Timestamp `protobuf:"bytes,2,opt,name=when,proto3" json:"when,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Schedules) Reset()         { *m = Schedules{} }
func (m *Schedules) String() string { return proto.CompactTextString(m) }
func (*Schedules) ProtoMessage()    {}
func (*Schedules) Descriptor() ([]byte, []int) {
	return fileDescriptor_scheduled_event_service_3cee47975d75ecf2, []int{0}
}
func (m *Schedules) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Schedules.Unmarshal(m, b)
}
func (m *Schedules) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Schedules.Marshal(b, m, deterministic)
}
func (dst *Schedules) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schedules.Merge(dst, src)
}
func (m *Schedules) XXX_Size() int {
	return xxx_messageInfo_Schedules.Size(m)
}
func (m *Schedules) XXX_DiscardUnknown() {
	xxx_messageInfo_Schedules.DiscardUnknown(m)
}

var xxx_messageInfo_Schedules proto.InternalMessageInfo

func (m *Schedules) GetEvents() *ScheduledEvents {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *Schedules) GetWhen() *timestamp.Timestamp {
	if m != nil {
		return m.When
	}
	return nil
}

type ListEventFilter struct {
	Sent                 bool     `protobuf:"varint,1,opt,name=sent,proto3" json:"sent,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListEventFilter) Reset()         { *m = ListEventFilter{} }
func (m *ListEventFilter) String() string { return proto.CompactTextString(m) }
func (*ListEventFilter) ProtoMessage()    {}
func (*ListEventFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_scheduled_event_service_3cee47975d75ecf2, []int{1}
}
func (m *ListEventFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListEventFilter.Unmarshal(m, b)
}
func (m *ListEventFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListEventFilter.Marshal(b, m, deterministic)
}
func (dst *ListEventFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListEventFilter.Merge(dst, src)
}
func (m *ListEventFilter) XXX_Size() int {
	return xxx_messageInfo_ListEventFilter.Size(m)
}
func (m *ListEventFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_ListEventFilter.DiscardUnknown(m)
}

var xxx_messageInfo_ListEventFilter proto.InternalMessageInfo

func (m *ListEventFilter) GetSent() bool {
	if m != nil {
		return m.Sent
	}
	return false
}

func init() {
	proto.RegisterType((*Schedules)(nil), "pb.Schedules")
	proto.RegisterType((*ListEventFilter)(nil), "pb.ListEventFilter")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ScheduledEventServiceClient is the client API for ScheduledEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ScheduledEventServiceClient interface {
	Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	Load(ctx context.Context, in *ScheduledEvent, opts ...grpc.CallOption) (*ScheduledEvent, error)
	Remove(ctx context.Context, in *ScheduledEvent, opts ...grpc.CallOption) (*Response, error)
	Create(ctx context.Context, in *ScheduledEvent, opts ...grpc.CallOption) (*Response, error)
	Update(ctx context.Context, in *ScheduledEvent, opts ...grpc.CallOption) (*Response, error)
	// should return those events which haven't expired yet
	NextSchedules(ctx context.Context, in *Schedules, opts ...grpc.CallOption) (*ScheduledEvents, error)
	// should return those events which are expired
	ExpiredSchedules(ctx context.Context, in *Schedules, opts ...grpc.CallOption) (*ScheduledEvents, error)
	List(ctx context.Context, in *ListEventFilter, opts ...grpc.CallOption) (*ScheduledEvents, error)
	Validate(ctx context.Context, in *ScheduledEvent, opts ...grpc.CallOption) (*Response, error)
}

type scheduledEventServiceClient struct {
	cc *grpc.ClientConn
}

func NewScheduledEventServiceClient(cc *grpc.ClientConn) ScheduledEventServiceClient {
	return &scheduledEventServiceClient{cc}
}

func (c *scheduledEventServiceClient) Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/pb.ScheduledEventService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduledEventServiceClient) Load(ctx context.Context, in *ScheduledEvent, opts ...grpc.CallOption) (*ScheduledEvent, error) {
	out := new(ScheduledEvent)
	err := c.cc.Invoke(ctx, "/pb.ScheduledEventService/Load", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduledEventServiceClient) Remove(ctx context.Context, in *ScheduledEvent, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/pb.ScheduledEventService/Remove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduledEventServiceClient) Create(ctx context.Context, in *ScheduledEvent, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/pb.ScheduledEventService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduledEventServiceClient) Update(ctx context.Context, in *ScheduledEvent, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/pb.ScheduledEventService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduledEventServiceClient) NextSchedules(ctx context.Context, in *Schedules, opts ...grpc.CallOption) (*ScheduledEvents, error) {
	out := new(ScheduledEvents)
	err := c.cc.Invoke(ctx, "/pb.ScheduledEventService/NextSchedules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduledEventServiceClient) ExpiredSchedules(ctx context.Context, in *Schedules, opts ...grpc.CallOption) (*ScheduledEvents, error) {
	out := new(ScheduledEvents)
	err := c.cc.Invoke(ctx, "/pb.ScheduledEventService/ExpiredSchedules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduledEventServiceClient) List(ctx context.Context, in *ListEventFilter, opts ...grpc.CallOption) (*ScheduledEvents, error) {
	out := new(ScheduledEvents)
	err := c.cc.Invoke(ctx, "/pb.ScheduledEventService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduledEventServiceClient) Validate(ctx context.Context, in *ScheduledEvent, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/pb.ScheduledEventService/Validate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScheduledEventServiceServer is the server API for ScheduledEventService service.
type ScheduledEventServiceServer interface {
	Ping(context.Context, *Request) (*Response, error)
	Load(context.Context, *ScheduledEvent) (*ScheduledEvent, error)
	Remove(context.Context, *ScheduledEvent) (*Response, error)
	Create(context.Context, *ScheduledEvent) (*Response, error)
	Update(context.Context, *ScheduledEvent) (*Response, error)
	// should return those events which haven't expired yet
	NextSchedules(context.Context, *Schedules) (*ScheduledEvents, error)
	// should return those events which are expired
	ExpiredSchedules(context.Context, *Schedules) (*ScheduledEvents, error)
	List(context.Context, *ListEventFilter) (*ScheduledEvents, error)
	Validate(context.Context, *ScheduledEvent) (*Response, error)
}

func RegisterScheduledEventServiceServer(s *grpc.Server, srv ScheduledEventServiceServer) {
	s.RegisterService(&_ScheduledEventService_serviceDesc, srv)
}

func _ScheduledEventService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduledEventServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ScheduledEventService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduledEventServiceServer).Ping(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduledEventService_Load_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduledEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduledEventServiceServer).Load(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ScheduledEventService/Load",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduledEventServiceServer).Load(ctx, req.(*ScheduledEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduledEventService_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduledEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduledEventServiceServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ScheduledEventService/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduledEventServiceServer).Remove(ctx, req.(*ScheduledEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduledEventService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduledEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduledEventServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ScheduledEventService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduledEventServiceServer).Create(ctx, req.(*ScheduledEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduledEventService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduledEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduledEventServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ScheduledEventService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduledEventServiceServer).Update(ctx, req.(*ScheduledEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduledEventService_NextSchedules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Schedules)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduledEventServiceServer).NextSchedules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ScheduledEventService/NextSchedules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduledEventServiceServer).NextSchedules(ctx, req.(*Schedules))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduledEventService_ExpiredSchedules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Schedules)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduledEventServiceServer).ExpiredSchedules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ScheduledEventService/ExpiredSchedules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduledEventServiceServer).ExpiredSchedules(ctx, req.(*Schedules))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduledEventService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEventFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduledEventServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ScheduledEventService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduledEventServiceServer).List(ctx, req.(*ListEventFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduledEventService_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduledEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduledEventServiceServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ScheduledEventService/Validate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduledEventServiceServer).Validate(ctx, req.(*ScheduledEvent))
	}
	return interceptor(ctx, in, info, handler)
}

var _ScheduledEventService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ScheduledEventService",
	HandlerType: (*ScheduledEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _ScheduledEventService_Ping_Handler,
		},
		{
			MethodName: "Load",
			Handler:    _ScheduledEventService_Load_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _ScheduledEventService_Remove_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _ScheduledEventService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ScheduledEventService_Update_Handler,
		},
		{
			MethodName: "NextSchedules",
			Handler:    _ScheduledEventService_NextSchedules_Handler,
		},
		{
			MethodName: "ExpiredSchedules",
			Handler:    _ScheduledEventService_ExpiredSchedules_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ScheduledEventService_List_Handler,
		},
		{
			MethodName: "Validate",
			Handler:    _ScheduledEventService_Validate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "scheduled-event-service.proto",
}

func init() {
	proto.RegisterFile("scheduled-event-service.proto", fileDescriptor_scheduled_event_service_3cee47975d75ecf2)
}

var fileDescriptor_scheduled_event_service_3cee47975d75ecf2 = []byte{
	// 330 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x52, 0x51, 0x4b, 0x32, 0x41,
	0x14, 0x55, 0xbf, 0x65, 0xf1, 0xbb, 0x7e, 0x7e, 0xc5, 0x0d, 0x41, 0x06, 0xa2, 0xd8, 0x08, 0x82,
	0x74, 0x0c, 0x23, 0xe8, 0x3d, 0xec, 0x49, 0x22, 0xd6, 0xea, 0x7d, 0xd7, 0xbd, 0xe9, 0xc0, 0xba,
	0x33, 0xcd, 0x8c, 0xe6, 0x9f, 0xec, 0x3f, 0x85, 0x33, 0x2b, 0x95, 0x19, 0xd8, 0xdb, 0xde, 0x7b,
	0xce, 0xb9, 0xf7, 0xdc, 0x3d, 0x03, 0x87, 0x66, 0x3c, 0xa5, 0x6c, 0x9e, 0x53, 0xd6, 0xa5, 0x05,
	0x15, 0xb6, 0x6b, 0x48, 0x2f, 0xc4, 0x98, 0xb8, 0xd2, 0xd2, 0x4a, 0xac, 0xa9, 0x94, 0x1d, 0x4d,
	0xa4, 0x9c, 0xe4, 0xd4, 0x73, 0x9d, 0x74, 0xfe, 0xdc, 0xb3, 0x62, 0x46, 0xc6, 0x26, 0x33, 0xe5,
	0x49, 0xec, 0xbf, 0x26, 0xa3, 0x64, 0x61, 0x4a, 0x11, 0x6b, 0x6a, 0x7a, 0x99, 0x93, 0xb1, 0x65,
	0xd9, 0xda, 0x58, 0xe1, 0xdb, 0xd1, 0x14, 0xfe, 0x8e, 0x4a, 0xc0, 0xe0, 0x39, 0x84, 0x0e, 0x33,
	0xed, 0xea, 0x71, 0xf5, 0xac, 0xd1, 0x3f, 0xe0, 0x2a, 0xe5, 0x6b, 0x38, 0x1b, 0x38, 0x28, 0x2e,
	0x29, 0xc8, 0x21, 0x78, 0x9d, 0x52, 0xd1, 0xae, 0x39, 0x2a, 0xe3, 0xde, 0x1f, 0x5f, 0xfb, 0xe3,
	0x0f, 0x6b, 0x7f, 0xb1, 0xe3, 0x45, 0xa7, 0xb0, 0x37, 0x14, 0xc6, 0xba, 0x29, 0xb7, 0x22, 0xb7,
	0xa4, 0x11, 0x21, 0x30, 0x54, 0x58, 0xb7, 0xad, 0x1e, 0xbb, 0xef, 0xfe, 0xdb, 0x1f, 0x68, 0x7d,
	0x5d, 0x39, 0xf2, 0xff, 0x02, 0x4f, 0x20, 0xb8, 0x17, 0xc5, 0x04, 0x1b, 0x2b, 0x57, 0xb1, 0x3f,
	0x8e, 0xfd, 0xf3, 0x85, 0xbf, 0x3c, 0xaa, 0xe0, 0x05, 0x04, 0x43, 0x99, 0x64, 0x88, 0xdf, 0xad,
	0xb3, 0x2d, 0xbd, 0xa8, 0x82, 0x1d, 0x08, 0x63, 0x9a, 0xc9, 0x05, 0x6d, 0xd5, 0x6c, 0xce, 0xef,
	0x40, 0x78, 0xa3, 0x29, 0xb1, 0x3b, 0xb3, 0x1f, 0x55, 0xb6, 0x2b, 0xfb, 0x0a, 0x9a, 0x77, 0xb4,
	0xb4, 0x1f, 0x79, 0x34, 0x3f, 0x8b, 0x0c, 0xdb, 0x16, 0x47, 0x54, 0xc1, 0x6b, 0xd8, 0x1f, 0x2c,
	0x95, 0xd0, 0x94, 0xfd, 0x56, 0xd9, 0x87, 0x60, 0x15, 0x09, 0x3a, 0x78, 0x23, 0x9c, 0x9f, 0x34,
	0x1c, 0xea, 0x4f, 0x49, 0x2e, 0x76, 0x3d, 0x2a, 0x0d, 0xdd, 0x83, 0xb8, 0x7c, 0x0f, 0x00, 0x00,
	0xff, 0xff, 0x79, 0xaa, 0xaa, 0xe4, 0xe3, 0x02, 0x00, 0x00,
}
